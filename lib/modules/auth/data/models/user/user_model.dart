import 'package:flutter/painting.dart';
import 'package:freezed_annotation/freezed_annotation.dart';
import 'package:urfit/core/presentation/style/colors.dart';
import 'package:urfit/core/presentation/utils/enums.dart';

part 'user_model.freezed.dart';
// required: associates our `main.dart` with the code generated by Freezed

// optional: Since our Person class is serializable, we must add this line.
// But if Person was not serializable, we could skip it.
part 'user_model.g.dart';

@freezed
class UserModel with _$UserModel {
  const factory UserModel({
    required int id,
    required String name,
    required String email,
    required bool? hasValidSubscription,
    @CountryConverter() required Country? country,
    @CityConverter() @JsonKey(name: 'city_id') required City? city,
    @GenderEnumConverter() GenderEnum? gender,
    @JsonKey(name: 'package_id') required int? packageId,
    required int? age,
    @JsonKey(name: 'current_weight') required int? currentWeight,
    required int? height,
    required int? otpCode,
    required List<Goal>? goals,
    @JsonKey(name: 'target_weight') required int? targetWeight,
    @BodyShapeConverter() @JsonKey(name: 'body_shape') required BodyShape? bodyShape,
    // @JsonKey(name: 'muscleFocuses') required List<MuscleFocus>? muscleFocuses,
    @JsonKey(name: 'training_days_per_week') required int? trainingDaysPerWeek,
    @JsonKey(name: 'body_parts') required List<String>? bodyParts,
    @JsonKey(name: 'exercise_days') required List<String>? exerciseDays,
    @JsonKey(name: 'workoutTypes') required List<WorkoutType>? workoutTypes,
    required List<Equipment>? equipments,
    @DietConverter() required Diet? diet,
    @JsonKey(name: 'recipe_types') required List<RecipeType>? recipeTypes,
    @JsonKey(name: 'foods_not_liked') required List<FoodNotLiked>? foodsNotLiked,
    @MealVarietyConverter() @JsonKey(name: 'meal_variety') required MealVariety? mealVariety,
    @JsonKey(name: 'email_verified_at') String? emailVerifiedAt,
    @JsonKey(name: 'is_checked') required bool? isChecked,
    @JsonKey(name: 'is_completed') required bool? isCompleted,
    @JsonKey(name: 'is_active') required bool? isActive,
    @JsonKey(name: 'country_key') required String? countryKey,
    @JsonKey(name: 'is_have_exercise_plan') required bool? haveExercisePlan,
    @JsonKey(name: 'is_have_meal_plan') required bool? haveMealPlan,
  }) = _User;

  factory UserModel.fromJson(Map<String, Object?> json) => _$UserModelFromJson(json);
}

// Custom converter for JSON
class GenderEnumConverter implements JsonConverter<GenderEnum?, int?> {
  const GenderEnumConverter();

  @override
  GenderEnum? fromJson(int? json) {
    switch (json) {
      case 0:
        return GenderEnum.male;
      case 1:
        return GenderEnum.female;
      default:
        return null;
    }
  }

  @override
  int? toJson(GenderEnum? gender) => gender?.index;
}

class BodyShapeConverter implements JsonConverter<BodyShape?, dynamic> {
  const BodyShapeConverter();

  @override
  BodyShape? fromJson(dynamic json) {
    if (json is List) {
      return null;
    } else if (json is Map) {
      return BodyShape.fromJson(json as Map<String, dynamic>);
    } else {
      return null;
    }
  }

  @override
  toJson(BodyShape? object) {
    return {
      'id': object?.id,
      'name': object?.name,
    };
  }
}

class CountryConverter implements JsonConverter<Country?, dynamic> {
  const CountryConverter();

  @override
  Country? fromJson(dynamic json) {
    if (json is List) {
      return null;
    } else if (json is Map) {
      return Country.fromJson(json as Map<String, dynamic>);
    } else {
      return null;
    }
  }

  @override
  toJson(Country? object) {
    return {
      'id': object?.id,
      'name': object?.name,
    };
  }
}

class CityConverter implements JsonConverter<City?, dynamic> {
  const CityConverter();

  @override
  City? fromJson(dynamic json) {
    if (json is List) {
      return null;
    } else if (json is Map) {
      return City.fromJson(json as Map<String, dynamic>);
    } else {
      return null;
    }
  }

  @override
  toJson(City? object) {
    return {
      'id': object?.id,
      'name': object?.name,
    };
  }
}

class DietConverter implements JsonConverter<Diet?, dynamic> {
  const DietConverter();

  @override
  Diet? fromJson(dynamic json) {
    if (json is List) {
      return null;
    } else if (json is Map) {
      return Diet.fromJson(json as Map<String, dynamic>);
    } else {
      return null;
    }
  }

  @override
  toJson(Diet? object) {
    return {
      'id': object?.id,
      'name': object?.name,
      "key": object?.key,
    };
  }
}

class MealVarietyConverter implements JsonConverter<MealVariety?, dynamic> {
  const MealVarietyConverter();

  @override
  MealVariety? fromJson(dynamic json) {
    if (json is List) {
      return null;
    } else if (json is Map) {
      return MealVariety.fromJson(json as Map<String, dynamic>);
    } else {
      return null;
    }
  }

  @override
  toJson(MealVariety? object) {
    return {
      'id': object?.id,
      'name': object?.name,
    };
  }
}

@freezed
class Country with _$Country {
  factory Country({
    required int id,
    required String name,
  }) = _Country;

  factory Country.fromJson(Map<String, dynamic> json) => _$CountryFromJson(json);
}

@freezed
class City with _$City {
  factory City({
    required int id,
    required String name,
  }) = _City;

  factory City.fromJson(Map<String, dynamic> json) => _$CityFromJson(json);
}

@freezed
class Goal with _$Goal {
  factory Goal({
    required int id,
    required String name,
  }) = _Goal;

  factory Goal.fromJson(Map<String, dynamic> json) => _$GoalFromJson(json);
}

@freezed
class BodyShape with _$BodyShape {
  factory BodyShape({
    required int id,
    required String name,
  }) = _BodyShape;

  factory BodyShape.fromJson(Map<String, dynamic> json) => _$BodyShapeFromJson(json);
}

@freezed
class MuscleFocus with _$MuscleFocus {
  factory MuscleFocus({
    required int id,
    required String name,
  }) = _MuscleFocus;

  factory MuscleFocus.fromJson(Map<String, dynamic> json) => _$MuscleFocusFromJson(json);
}

@freezed
class WorkoutType with _$WorkoutType {
  factory WorkoutType({
    required int id,
    required String name,
  }) = _WorkoutType;

  factory WorkoutType.fromJson(Map<String, dynamic> json) => _$WorkoutTypeFromJson(json);
}

@freezed
class Equipment with _$Equipment {
  factory Equipment({
    required int id,
    required String name,
    required String image,
  }) = _Equipment;

  factory Equipment.fromJson(Map<String, dynamic> json) => _$EquipmentFromJson(json);
}

@freezed
class Diet with _$Diet {
  factory Diet({
    required int id,
    required String key,
    required String name,
  }) = _Diet;

  factory Diet.fromJson(Map<String, dynamic> json) => _$DietFromJson(json);
}

@freezed
class RecipeType with _$RecipeType {
  factory RecipeType({
    required int id,
    required String name,
  }) = _RecipeType;

  factory RecipeType.fromJson(Map<String, dynamic> json) => _$RecipeTypeFromJson(json);
}

@freezed
class FoodNotLiked with _$FoodNotLiked {
  factory FoodNotLiked({
    required int id,
    required String name,
  }) = _FoodNotLiked;

  factory FoodNotLiked.fromJson(Map<String, dynamic> json) => _$FoodNotLikedFromJson(json);
}

@freezed
class MealVariety with _$MealVariety {
  factory MealVariety({
    required int id,
    required String name,
  }) = _MealVariety;

  factory MealVariety.fromJson(Map<String, dynamic> json) => _$MealVarietyFromJson(json);
}

extension UserModelExtension on UserModel {
  bool get hasCompleteStepOne =>
      hasValidSubscription == true || (age != null && currentWeight != null && height != null);
  bool get hasCompleteStepTwo => (goals?.isNotEmpty ?? false);
  bool get hasCompleteStepThree =>
      (bodyParts?.isNotEmpty ?? false) &&
      (mealVariety != null) &&
      (foodsNotLiked?.isNotEmpty ?? false) &&
      (diet != null) &&
      (targetWeight != null) &&
      (trainingDaysPerWeek != null) &&
      (workoutTypes?.isNotEmpty ?? false) &&
      (equipments?.isNotEmpty ?? false);

  bool get hasCompleteProfile => hasCompleteStepOne && hasCompleteStepTwo && hasCompleteStepThree;

  Color get color => gender == GenderEnum.male ? Co.primaryColor : Co.primaryColorFemale;
}
